import { Args, Flags } from '@oclif/core';
import VegaCommand, { VegaCommandOptions, selectWalletFlags } from '../../lib/vega-command.js';
import {
  getNativeBCHTokenInfo, bigIntToDecString, binToHex, bigIntFromDecString,
  moriaTxResultSummaryJSON, convertUTXOToJSON,
} from '../../lib/util.js';
import { ValueError } from '../../lib/exceptions.js';
import { MUSDV0_SYMBOL, MUSDV0_DECIMALS } from '../../lib/constants.js';
import type { UTXOWithNFT, Fraction  } from '@cashlab/common';
import { uint8ArrayEqual, hexToBin } from '@cashlab/common/util.js';
import type { TxResult } from '@cashlab/common/types.js';

export default class Moria0RepayLoan extends VegaCommand<typeof Moria0RepayLoan> {
  static args = {
    loan_outpoint: Args.string({
      name: 'loan_outpoint',
      required: true,
      description: "The outpoint of the loan nft utxo. <txid>:<index>",
    }),
    next_collateral_percentage: Args.string({
      name: 'next_collateral_percentage',
      required: true,
      description: "A decimal number representing next collateral percentage or MIN to reduce the collateral to the minimum amount.",
    }),
  };
  static flags = {
    ...selectWalletFlags(),
    'txfee-per-byte': Flags.string({
      description: 'Specify the txfee per byte in sats.',
      required: true,
      default: '1',
    }),
    'broadcast': Flags.boolean({
      description: `Broadcast the transactions generated by the command.`,
    }),
  };
  static vega_options: VegaCommandOptions = {
    require_wallet_selection: true,
  };

  static description = ``;

  static examples = [
    `<%= config.bin %> <%= command.id %>`,
  ];

  async run (): Promise<any> {
    const { args, flags } = this;
    const bch_token_info = getNativeBCHTokenInfo();
    const wallet_name = this.getSelectedWalletName();
    const { default: MoriaV0 } = await import('@cashlab/moria/v0/index.js');
    const loans: UTXOWithNFT[] = await this.callModuleMethod('moria0.get-my-loans', wallet_name);
    let selected_loan_outpoint;
    {
      const [ outpoint_txid, outpoint_index ] = args.loan_outpoint.split(':');
      if (typeof outpoint_index != 'string' || isNaN(parseInt(outpoint_index)) && parseInt(outpoint_index) > 0) {
        throw new ValueError(`loan_outpoint index is not a positive number!`);
      }
      const outpoint_txhash = hexToBin(outpoint_txid as string);
      if (outpoint_txhash.length != 32) {
        throw new ValueError(`loan_outpoint txhash should be a 32 bytes represented in hexstring!`);
      }
      selected_loan_outpoint = { txhash: outpoint_txhash, index: parseInt(outpoint_index) };
    }
    const selected_loan: UTXOWithNFT | undefined = loans.find((a) => uint8ArrayEqual(a.outpoint.txhash, selected_loan_outpoint.txhash) && a.outpoint.index == selected_loan_outpoint.index);
    if (selected_loan == null) {
      throw new ValueError(`Provided loan_outpoint not found in the wallet's loans.`);
    }
    let next_collateral_rate: Fraction | 'MIN';
    if (args.next_collateral_percentage.toUpperCase() != 'MIN') {
      const collateral_rate_numerator = bigIntFromDecString(args.next_collateral_percentage, 10);
      if (!(collateral_rate_numerator >= 1500000000000n)) {
        throw new ValueError(`next_collateral_percentage should be greater than or equal to 150`);
      }
      next_collateral_rate = { numerator: collateral_rate_numerator, denominator: 1000000000000n };
    } else {
      next_collateral_rate = 'MIN';
    }
    const broadcast = flags.broadcast;
    const txfee_per_byte: bigint = BigInt(flags['txfee-per-byte']);
    if (txfee_per_byte < 0n) {
      throw new Error('txfee-per-byte should be a positive integer');
    }
    const result = await this.callModuleMethod('moria0.reduce-loan', wallet_name, selected_loan, next_collateral_rate, { broadcast, txfee_per_byte, verify: true });
    this.log('Summary:');
    try {
      const loan_params = MoriaV0.parseParametersFromLoanNFTCommitment(result.loan_utxo.output.token.nft.commitment);
      this.log(`  Loan amount post refinance: ${bigIntToDecString(loan_params.amount, MUSDV0_DECIMALS)} ${MUSDV0_SYMBOL}`);
      this.log(`  Loan collateral post refinance: ${bigIntToDecString(result.loan_utxo.output.amount, bch_token_info.decimals)} ${bch_token_info.symbol}`);
      this.log(`  BCH payout: ${bigIntToDecString(selected_loan.output.amount - result.loan_utxo.output.amount - result.oracle_use_fee - result.txfee, bch_token_info.decimals)} ${bch_token_info.symbol}`);
      this.log(`  Oracle use fee: ${result.oracle_use_fee} sats`);
      this.log(`  Transaction fee: ${result.txfee} sats`);
    } catch (err) {
      this.log(`  Parse error: [${(err as any).name}] ${(err as any).message}`);
    }
    return {
      tx_result_chain: result.tx_result_chain.map((a: TxResult) => moriaTxResultSummaryJSON(a)),
      txfee: result.txfee+'',
      payouts: result.payouts.map(convertUTXOToJSON),
      loan_utxo: convertUTXOToJSON(result.loan_utxo),
      oracle_use_fee: result.oracle_use_fee+'',
    };

  }
}
